{"ast":null,"code":"\"use strict\";\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Debug = void 0;\n\nvar containers_1 = require(\"./containers\");\n\nvar settings_1 = require(\"./settings\");\n/**\r\n * Represents a utility module to view debug information inside the DOM.\r\n * This is disabled by default and needs to manually be enabled by setting\r\n * the '.enabled' field to true.\r\n *\r\n * While disabled, the utility will not fetch stats and update itself.\r\n */\n\n\nvar Debug =\n/** @class */\nfunction () {\n  /**\r\n   * Registers a new debug utility that is attached to the given scene.\r\n   *\r\n   * @param scene The scene to attach to.\r\n   */\n  function Debug(scene) {\n    this.scene = scene;\n    /**\r\n     * The rate at which the debug interface should refresh itself (per second).\r\n     */\n\n    this.refreshRate = 8;\n    /**\r\n     * The timer counting down to refreshes.\r\n     */\n\n    this.refreshTimer = 1 / this.refreshRate;\n  }\n  /**\r\n   * Processes a tick event in the interface. This checks if enough has passed to\r\n   * trigger a refresh, and if so, fetches the debug information and updates the DOM.\r\n   *\r\n   * @param delta The time that has elapsed since the last tick.\r\n   */\n\n\n  Debug.prototype.tick = function (delta) {\n    var container = containers_1.debugContainer.current; // If the current display style does not match the style inferred from the\n    // enabled-state, update it.\n\n    var displayStyle = settings_1.settings.debug ? \"block\" : \"none\";\n\n    if (container.style.display !== displayStyle) {\n      container.style.display = displayStyle;\n    }\n\n    if (!settings_1.settings.debug) {\n      // If the interface is not enabled, don't fetch or update any infos.\n      return;\n    }\n\n    this.refreshTimer += delta;\n\n    if (this.refreshTimer > 1 / this.refreshRate) {\n      this.refreshTimer = 0; // Update the container with the fetched information joined on line breaks.\n\n      container.innerHTML = this.getDebugInformation(delta).join(\"<br>\");\n    }\n  };\n  /**\r\n   * Fetches the debug information from the specified delta and the linked scene.\r\n   *\r\n   * @returns An array of debugging information, formatted as HTML.\r\n   */\n\n\n  Debug.prototype.getDebugInformation = function (delta) {\n    // Count emitters and particles.\n    var emitters = this.scene.emitters.length;\n    var particles = this.scene.emitters.reduce(function (acc, cur) {\n      return acc + cur.particles.length;\n    }, 0);\n    var infos = [\"<b>party.js Debug</b>\", \"--------------\", \"FPS: \" + Math.round(1 / delta), \"Emitters: \" + emitters, \"Particles: \" + particles]; // Emitter informations are formatted using their index, internal timer\n    // and total particle count.\n\n    var emitterInfos = this.scene.emitters.map(function (emitter) {\n      return [// Show the current loop and the total loops.\n      \"\\u2B6F: \" + (emitter[\"currentLoop\"] + 1) + \"/\" + (emitter.options.loops >= 0 ? emitter.options.loops : \"âˆž\"), // Show the amount of particle contained.\n      \"\\u03A3p: \" + emitter.particles.length, // Show the internal timer.\n      !emitter.isExpired ? \"\\u03A3t: \" + emitter[\"durationTimer\"].toFixed(3) + \"s\" : \"<i>expired</i>\"].join(\", \");\n    });\n    infos.push.apply(infos, __spreadArray([\"--------------\"], emitterInfos));\n    return infos;\n  };\n\n  return Debug;\n}();\n\nexports.Debug = Debug;","map":null,"metadata":{},"sourceType":"script"}
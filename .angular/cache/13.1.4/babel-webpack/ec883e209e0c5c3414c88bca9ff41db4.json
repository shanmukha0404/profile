{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Renderer = void 0;\n\nvar __1 = require(\"..\");\n\nvar vector_1 = require(\"../components/vector\");\n\nvar containers_1 = require(\"../containers\");\n\nvar shapes_1 = require(\"../systems/shapes\");\n\nvar util_1 = require(\"../util\");\n/**\r\n * Represents a renderer used to draw particles to the DOM via HTML\r\n * elements. Additionally, it is responsible for purging the elements\r\n * of destroyed particles from the DOM.\r\n */\n\n\nvar Renderer =\n/** @class */\nfunction () {\n  function Renderer() {\n    /**\r\n     * The lookup of elements currently handled by the renderer, with the\r\n     * particle ID as key and a HTMLElement as the value.\r\n     */\n    this.elements = new Map();\n    /**\r\n     * The normalized direction the light comes from.\r\n     */\n\n    this.light = new vector_1.Vector(0, 0, 1);\n    /**\r\n     * Whether or not the renderer should actually draw particles.\r\n     */\n\n    this.enabled = true; // Respect that users might prefer reduced motion.\n    // See: https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion\n\n    this.enabled = !__1.settings.respectReducedMotion || !window.matchMedia(\"(prefers-reduced-motion)\").matches;\n  }\n  /**\r\n   * Begins a new render block. During the rendering phase, a list of rendered particles\r\n   * is tracked, so that stale particles can be removed later.\r\n   */\n\n\n  Renderer.prototype.begin = function () {\n    this.renderedParticles = [];\n  };\n  /**\r\n   * Terminates an existing render block. This checks which particles were rendered\r\n   * during the block and purges all unused HTMLElements from the DOM.\r\n   *\r\n   * @returns The amount of particles that were rendered.\r\n   */\n\n\n  Renderer.prototype.end = function () {\n    var it = this.elements.keys();\n    var result = it.next();\n\n    while (!result.done) {\n      var id = result.value;\n\n      if (!this.renderedParticles.includes(id)) {\n        this.elements.get(id).remove();\n        this.elements.delete(id);\n      }\n\n      result = it.next();\n    }\n\n    return this.renderedParticles.length;\n  };\n  /**\r\n   * Renders an individual particle to the DOM. If the particle is rendered for the first\r\n   * time, a HTMLElement will be created using the emitter's render settings.\r\n   *\r\n   * @param particle The particle to be rendered.\r\n   * @param emitter The system containing the particle.\r\n   */\n\n\n  Renderer.prototype.renderParticle = function (particle, emitter) {\n    if (!this.enabled) return;\n    var options = emitter.renderer; // Ensure that an element for the particle exists.\n\n    var element = this.elements.has(particle.id) ? this.elements.get(particle.id) : this.createParticleElement(particle, options);\n\n    if (options.applyColor) {\n      // If the options offer a coloring method, apply it.\n      options.applyColor(particle.color, element);\n    }\n\n    if (options.applyOpacity) {\n      // If the options offer an opacity modifying method, apply it.\n      options.applyOpacity(particle.opacity, element);\n    }\n\n    if (options.applyLighting) {\n      // If the options offer a lighting method, apply it.\n      // Lighting is calculated as a combination of the particle's normal\n      // direction and the lighting direction.\n      var normal = util_1.rotationToNormal(particle.rotation);\n      var lightingCoefficient = normal.dot(this.light);\n      options.applyLighting(lightingCoefficient, element);\n    }\n\n    if (options.applyTransform) {\n      // If the options offer a transformation method, apply it.\n      // This ensures the particle is rendered at the correct position with the correct rotation.\n      options.applyTransform(particle, element);\n    } // Mark the particle as rendered.\n\n\n    this.renderedParticles.push(particle.id);\n  };\n  /**\r\n   * Creates the HTMLElement for a particle that does not have one already.\r\n   */\n\n\n  Renderer.prototype.createParticleElement = function (particle, options) {\n    // Resolve the element returned from the factory.\n    var resolved = shapes_1.resolveShapeFactory(options.shapeFactory); // Clone the node to ensure we do not break existing elements.\n\n    var element = resolved.cloneNode(true); // Ensure that the elements can be \"stacked\" ontop of eachother.\n\n    element.style.position = \"absolute\"; // Register the new element in the map, while appending the new element to the DOM.\n\n    this.elements.set(particle.id, containers_1.particleContainer.current.appendChild(element));\n    return element;\n  };\n\n  return Renderer;\n}();\n\nexports.Renderer = Renderer;","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Spline = void 0;\n\nvar math_1 = require(\"../systems/math\");\n/**\r\n * Represents a spline that can be used to continueously evaluate a function\r\n * between keys. The base implementation is kept generic, so the functionality\r\n * can easily be implemented for similar constructs, such as gradients.\r\n */\n\n\nvar Spline =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new spline instance, using the specified keys.\r\n   * Note that you have to pass at least one key.\r\n   */\n  function Spline() {\n    var keys = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      keys[_i] = arguments[_i];\n    }\n\n    if (keys.length === 0) {\n      throw new Error(\"Splines require at least one key.\");\n    }\n\n    if (Array.isArray(keys[0])) {\n      throw new Error(\"You are trying to pass an array to the spline constructor, which is not supported. \" + \"Try to spread the array into the constructor instead.\");\n    }\n\n    this.keys = keys;\n  }\n  /**\r\n   * Evaluates the spline at the given time.\r\n   */\n\n\n  Spline.prototype.evaluate = function (time) {\n    if (this.keys.length === 0) {\n      throw new Error(\"Attempt to evaluate a spline with no keys.\");\n    }\n\n    if (this.keys.length === 1) {\n      // The spline only contains one key, therefore is constant.\n      return this.keys[0].value;\n    } // Sort the keys and figure out the first key above the passed time.\n\n\n    var ascendingKeys = this.keys.sort(function (a, b) {\n      return a.time - b.time;\n    });\n    var upperKeyIndex = ascendingKeys.findIndex(function (g) {\n      return g.time > time;\n    }); // If the found index is either 0 or -1, the specified time falls out\n    // of the range of the supplied keys. In that case, the value of the\n    // nearest applicant key is returned.\n\n    if (upperKeyIndex === 0) {\n      return ascendingKeys[0].value;\n    }\n\n    if (upperKeyIndex === -1) {\n      return ascendingKeys[ascendingKeys.length - 1].value;\n    } // Otherwise, find the bounding keys, and extrapolate the time between\n    // the two. This is then used to interpolate between the two keys,\n    // using the provided implementation.\n\n\n    var lowerKey = ascendingKeys[upperKeyIndex - 1];\n    var upperKey = ascendingKeys[upperKeyIndex];\n    var containedTime = math_1.invlerp(lowerKey.time, upperKey.time, time);\n    return this.interpolate(lowerKey.value, upperKey.value, containedTime);\n  };\n\n  return Spline;\n}();\n\nexports.Spline = Spline;","map":null,"metadata":{},"sourceType":"script"}
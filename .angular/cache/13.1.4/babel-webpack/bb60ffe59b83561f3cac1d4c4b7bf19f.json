{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ModuleBuilder = void 0;\n\nvar components_1 = require(\"../components\");\n/**\r\n * Represents a builder for particle modules. Returns an evaluatable module\r\n * function, that can be consumed by emitters.\r\n *\r\n * @remarks\r\n * Not all properties can be driven. TypeScript will validate this at compile time,\r\n * but no internal validation is performed due to performance reasons. Also, note\r\n * that the driving factor is \"lifetime\" by default.\r\n *\r\n * @example\r\n * ```ts\r\n * new ModuleBuilder()\r\n *     .drive(\"size\")\r\n *     .by((t) => t * 2)\r\n *     .through(\"lifetime\")\r\n *     .build();\r\n * ```\r\n */\n\n\nvar ModuleBuilder =\n/** @class */\nfunction () {\n  function ModuleBuilder() {\n    /**\r\n     * The factor driving the built function.\r\n     *\r\n     * @defaultValue \"lifetime\"\r\n     */\n    this.factor = \"lifetime\";\n    this.isRelative = false;\n  }\n  /**\r\n   * Specifies the key in the particle that should be driven.\r\n   *\r\n   * @remarks\r\n   * Note that not all of a particle's properties are drivable through modules. If you\r\n   * need full control of a particle inside of a module, you can use a module function directly.\r\n   *\r\n   * @returns The chained builder instance.\r\n   */\n\n\n  ModuleBuilder.prototype.drive = function (key) {\n    this.driverKey = key;\n    return this;\n  };\n  /**\r\n   * Specifies the factor to drive the evaluated value by. Supports \"lifetime\" and \"size\".\r\n   *\r\n   * @returns The chained builder instance.\r\n   */\n\n\n  ModuleBuilder.prototype.through = function (factor) {\n    this.factor = factor;\n    return this;\n  };\n  /**\r\n   * Specifies the value to drive the module behaviour by. This can be a constant,\r\n   * a spline or an evaluable function. Note that in the last case, the driving\r\n   * factor is passed as a parameter.\r\n   *\r\n   * @returns The chained builder instance.\r\n   */\n\n\n  ModuleBuilder.prototype.by = function (driver) {\n    this.driverValue = driver;\n    return this;\n  };\n  /**\r\n   * Specifies that the module function is supposed to act relative to the\r\n   * properties initial value.\r\n   *\r\n   * @remarks\r\n   * Note that this is only possible if an \"initial*\" property exists on the\r\n   * particle object. The operation applied to the initial and new value\r\n   * is dependant on their type:\r\n   * - `Vector`: Both vectors are added.\r\n   * - `number`: Both numbers are multiplied.\r\n   *\r\n   * For more advanced relative customizations, consider using the particle\r\n   * object in the driver value function instead, like:\r\n   * ```ts\r\n   * .by((t, p) => p.initialSize + t * 2);\r\n   * ```\r\n   */\n\n\n  ModuleBuilder.prototype.relative = function (isRelative) {\n    if (isRelative === void 0) {\n      isRelative = true;\n    }\n\n    this.isRelative = isRelative;\n    return this;\n  };\n  /**\r\n   * Consumes the builder and returns an evaluatable module function.\r\n   *\r\n   * @remarks\r\n   * Note that you need to specify the driving key and value, otherwise an error\r\n   * will be thrown.\r\n   */\n\n\n  ModuleBuilder.prototype.build = function () {\n    var _this = this;\n\n    if (typeof this.driverKey === \"undefined\") {\n      throw new Error(\"No driving key was provided in the module builder. Did you forget a '.drive()' call?\");\n    }\n\n    if (typeof this.driverValue === \"undefined\") {\n      throw new Error(\"No driving value was provided in the module builder. Did you forget a '.through()' call?\");\n    }\n\n    return function (particle) {\n      updateDrivenProperty(particle, _this.driverKey, evaluateModuleDriver(_this.driverValue, calculateModuleFactor(_this.factor, particle), particle), _this.isRelative);\n    };\n  };\n\n  return ModuleBuilder;\n}();\n\nexports.ModuleBuilder = ModuleBuilder;\n/**\r\n * Evaluates the module driver using a specified factor.\r\n */\n\nfunction evaluateModuleDriver(driver, factor, particle) {\n  if (typeof driver === \"object\" && \"evaluate\" in driver) {\n    return driver.evaluate(factor);\n  }\n\n  if (typeof driver === \"function\") {\n    return driver(factor, particle);\n  }\n\n  return driver;\n}\n/**\r\n * Calculates a module factor using a specified particle as context.\r\n */\n\n\nfunction calculateModuleFactor(factor, particle) {\n  switch (factor) {\n    case \"lifetime\":\n      return particle.initialLifetime - particle.lifetime;\n\n    case \"relativeLifetime\":\n      return (particle.initialLifetime - particle.lifetime) / particle.initialLifetime;\n\n    case \"size\":\n      return particle.size;\n\n    default:\n      throw new Error(\"Invalid driving factor '\" + factor + \"'.\");\n  }\n}\n/**\r\n * Updates a driven property of a particle using the specified value.\r\n *\r\n * @remarks\r\n * If the operation is marked as relative, the function infers the new value\r\n * through the value's type. Note that relative properties must have a\r\n * corresponding \"initial*\" value in the particle's properties.\r\n */\n\n\nfunction updateDrivenProperty(particle, key, value, relative) {\n  if (relative === void 0) {\n    relative = false;\n  }\n\n  if (!relative) {\n    particle[key] = value;\n  } else {\n    var initial = particle[\"initial\" + key[0].toUpperCase() + key.substr(1)];\n\n    if (typeof initial === \"undefined\") {\n      throw new Error(\"Unable to use relative chaining with key '\" + key + \"'; no initial value exists.\");\n    }\n\n    if (value instanceof components_1.Vector) {\n      updateDrivenProperty(particle, key, initial.add(value));\n    } else if (typeof value === \"number\") {\n      updateDrivenProperty(particle, key, initial * value);\n    } else {\n      throw new Error(\"Unable to use relative chaining with particle key '\" + key + \"'; no relative operation for '\" + value + \"' could be inferred.\");\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}
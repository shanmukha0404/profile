{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Emitter = void 0;\n\nvar vector_1 = require(\"../components/vector\");\n\nvar settings_1 = require(\"../settings\");\n\nvar variation_1 = require(\"../systems/variation\");\n\nvar config_1 = require(\"../util/config\");\n\nvar options_1 = require(\"./options\");\n\nvar particle_1 = require(\"./particle\");\n/**\r\n * Represents an emitter that is responsible for spawning and updating particles.\r\n *\r\n * Particles themselves are just data-holders, with the system acting upon them and\r\n * modifying them. The modifications are done mainly via modules, that use the\r\n * particle's data together with some function to apply temporal transitions.\r\n *\r\n * @see Particle\r\n * @see ParticleModifierModule\r\n */\n\n\nvar Emitter =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new emitter, using default options.\r\n   */\n  function Emitter(options) {\n    /**\r\n     * The particles currently contained within the system.\r\n     */\n    this.particles = [];\n    this.currentLoop = 0; // The current loop index.\n\n    this.durationTimer = 0; // Measures the current runtime duration, to allow loops to reset.\n\n    this.emissionTimer = 0; // Measures the current emission timer, to allow spawning particles in intervals.\n\n    this.attemptedBurstIndices = []; // The indices of the particle bursts that were attempted this loop.\n\n    this.options = config_1.overrideDefaults(options_1.getDefaultEmitterOptions(), options === null || options === void 0 ? void 0 : options.emitterOptions);\n    this.emission = config_1.overrideDefaults(options_1.getDefaultEmissionOptions(), options === null || options === void 0 ? void 0 : options.emissionOptions);\n    this.renderer = config_1.overrideDefaults(options_1.getDefaultRendererOptions(), options === null || options === void 0 ? void 0 : options.rendererOptions);\n  }\n\n  Object.defineProperty(Emitter.prototype, \"isExpired\", {\n    /**\r\n     * Checks if the emitter is already expired and can be removed.\r\n     * Expired emitters do not emit new particles.\r\n     */\n    get: function () {\n      return this.options.loops >= 0 && this.currentLoop >= this.options.loops;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Emitter.prototype, \"canRemove\", {\n    /**\r\n     * Checks if the emitter can safely be removed.\r\n     * This is true if no more particles are active.\r\n     */\n    get: function () {\n      return this.particles.length === 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Clears all particles inside the emitter.\r\n   *\r\n   * @returns The number of cleared particles.\r\n   */\n\n  Emitter.prototype.clearParticles = function () {\n    return this.particles.splice(0).length;\n  };\n  /**\r\n   * Processes a tick of the emitter, using the elapsed time.\r\n   *\r\n   * @remarks\r\n   * This handles a few things, namely:\r\n   * - Incrementing the duration timer and potentially incrementing the loop.\r\n   * - Handling particle bursts & emissions.\r\n   * - Despawning particles conditionally.\r\n   *\r\n   * @param delta The time, in seconds, passed since the last tick.\r\n   */\n\n\n  Emitter.prototype.tick = function (delta) {\n    if (!this.isExpired) {\n      this.durationTimer += delta;\n\n      if (this.durationTimer >= this.options.duration) {\n        this.currentLoop++; // To start a new loop, the duration timer and attempted bursts are reset.\n\n        this.durationTimer = 0;\n        this.attemptedBurstIndices = [];\n      } // We need to check the expiry again, in case the added loop or duration changed something.\n\n\n      if (!this.isExpired) {\n        // Iterate over the bursts, attempting to execute them if the time is ready.\n        var burstIndex = 0;\n\n        for (var _i = 0, _a = this.emission.bursts; _i < _a.length; _i++) {\n          var burst = _a[_i];\n\n          if (burst.time <= this.durationTimer) {\n            // Has the burst already been attempted? If not ...\n            if (!this.attemptedBurstIndices.includes(burstIndex)) {\n              // Perform the burst, emitting a variable amount of particles.\n              var count = variation_1.evaluateVariation(burst.count);\n\n              for (var i = 0; i < count; i++) {\n                this.emitParticle();\n              } // Mark the burst as attempted.\n\n\n              this.attemptedBurstIndices.push(burstIndex);\n            }\n          }\n\n          burstIndex++;\n        } // Handle the 'emission over time'. By using a while-loop instead of a simple\n        // if-condition, we take high deltas into account, and ensure that the correct\n        // number of particles will consistently be emitted.\n\n\n        this.emissionTimer += delta;\n        var delay = 1 / this.emission.rate;\n\n        while (this.emissionTimer > delay) {\n          this.emissionTimer -= delay;\n          this.emitParticle();\n        }\n      }\n    }\n\n    var _loop_1 = function (i) {\n      var particle = this_1.particles[i];\n      this_1.tickParticle(particle, delta); // Particles should be despawned (i.e. removed from the collection) if any of\n      // the despawning rules apply to them.\n\n      if (this_1.options.despawningRules.some(function (rule) {\n        return rule(particle);\n      })) {\n        this_1.particles.splice(i, 1);\n      }\n    };\n\n    var this_1 = this;\n\n    for (var i = this.particles.length - 1; i >= 0; i--) {\n      _loop_1(i);\n    }\n  };\n  /**\r\n   * Performs an internal tick for the particle.\r\n   *\r\n   * @remarks\r\n   * This method controls the particle's lifetime, location and velocity, according\r\n   * to the elapsed delta and the configuration. Additionally, each of the emitter's\r\n   * modules is applied to the particle.\r\n   *\r\n   * @param particle The particle to apply the tick for.\r\n   * @param delta The time, in seconds, passed since the last tick.\r\n   */\n\n\n  Emitter.prototype.tickParticle = function (particle, delta) {\n    particle.lifetime -= delta;\n\n    if (this.options.useGravity) {\n      // Apply gravitational acceleration to the particle.\n      particle.velocity = particle.velocity.add(vector_1.Vector.up.scale(settings_1.settings.gravity * delta));\n    } // Apply the particle's velocity to its location.\n\n\n    particle.location = particle.location.add(particle.velocity.scale(delta)); // Apply the modules to the particle.\n\n    for (var _i = 0, _a = this.options.modules; _i < _a.length; _i++) {\n      var moduleFunction = _a[_i];\n      moduleFunction(particle);\n    }\n  };\n  /**\r\n   * Emits a particle using the registered settings.\r\n   * Also may despawn a particle if the maximum number of particles is exceeded.\r\n   */\n\n\n  Emitter.prototype.emitParticle = function () {\n    var particle = new particle_1.Particle({\n      location: this.emission.sourceSampler(),\n      lifetime: variation_1.evaluateVariation(this.emission.initialLifetime),\n      velocity: vector_1.Vector.from2dAngle(variation_1.evaluateVariation(this.emission.angle)).scale(variation_1.evaluateVariation(this.emission.initialSpeed)),\n      size: variation_1.evaluateVariation(this.emission.initialSize),\n      rotation: variation_1.evaluateVariation(this.emission.initialRotation),\n      color: variation_1.evaluateVariation(this.emission.initialColor)\n    });\n    this.particles.push(particle); // Ensure that no more particles than 'maxParticles' can exist.\n\n    if (this.particles.length > this.options.maxParticles) {\n      this.particles.shift();\n    }\n\n    return particle;\n  };\n\n  return Emitter;\n}();\n\nexports.Emitter = Emitter;","map":null,"metadata":{},"sourceType":"script"}